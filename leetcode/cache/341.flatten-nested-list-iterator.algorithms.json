{"id":341,"fid":"341","name":"扁平化嵌套列表迭代器","slug":"flatten-nested-list-iterator","link":"https://leetcode.cn/problems/flatten-nested-list-iterator/description/","percent":72.71638866969606,"level":"Medium","category":"algorithms","en_name":"Flatten Nested List Iterator","cn_name":"扁平化嵌套列表迭代器","totalAC":"81.3K","totalSubmit":"111.7K","likes":551,"dislikes":0,"desc":"<p>给你一个嵌套的整数列表 <code>nestedList</code> 。每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。</p>\n\n<p>实现扁平迭代器类 <code>NestedIterator</code> ：</p>\n\n<ul>\n\t<li><code>NestedIterator(List&lt;NestedInteger&gt; nestedList)</code> 用嵌套列表 <code>nestedList</code> 初始化迭代器。</li>\n\t<li><code>int next()</code> 返回嵌套列表的下一个整数。</li>\n\t<li><code>boolean hasNext()</code> 如果仍然存在待迭代的整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n</ul>\n\n<p>你的代码将会用下述伪代码检测：</p>\n\n<pre>\ninitialize iterator with nestedList\nres = []\nwhile iterator.hasNext()\n    append iterator.next() to the end of res\nreturn res</pre>\n\n<p>如果 <code>res</code> 与预期的扁平化列表匹配，那么你的代码将会被判为正确。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nestedList = [[1,1],2,[1,1]]\n<strong>输出：</strong>[1,1,2,1,1]\n<strong>解释：</strong>通过重复调用&nbsp;<em>next </em>直到&nbsp;<em>hasNex</em>t 返回 false，<em>next&nbsp;</em>返回的元素的顺序应该是: <code>[1,1,2,1,1]</code>。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nestedList = [1,[4,[6]]]\n<strong>输出：</strong>[1,4,6]\n<strong>解释：</strong>通过重复调用&nbsp;<em>next&nbsp;</em>直到&nbsp;<em>hasNex</em>t 返回 false，<em>next&nbsp;</em>返回的元素的顺序应该是: <code>[1,4,6]</code>。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nestedList.length &lt;= 500</code></li>\n\t<li>嵌套列表中的整数值在范围 <code>[-10<sup>6</sup>, 10<sup>6</sup>]</code> 内</li>\n</ul>\n","templates":[{"value":"cpp","text":"C++","defaultCode":"/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *   public:\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     bool isInteger() const;\n *\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\n *     // The result is undefined if this NestedInteger holds a nested list\n *     int getInteger() const;\n *\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\n *     // The result is undefined if this NestedInteger holds a single integer\n *     const vector<NestedInteger> &getList() const;\n * };\n */\n\nclass NestedIterator {\npublic:\n    NestedIterator(vector<NestedInteger> &nestedList) {\n        \n    }\n    \n    int next() {\n        \n    }\n    \n    bool hasNext() {\n        \n    }\n};\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * NestedIterator i(nestedList);\n * while (i.hasNext()) cout << i.next();\n */"},{"value":"java","text":"Java","defaultCode":"/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * public interface NestedInteger {\n *\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\n *     public boolean isInteger();\n *\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\n *     // Return null if this NestedInteger holds a nested list\n *     public Integer getInteger();\n *\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\n *     // Return empty list if this NestedInteger holds a single integer\n *     public List<NestedInteger> getList();\n * }\n */\npublic class NestedIterator implements Iterator<Integer> {\n\n    public NestedIterator(List<NestedInteger> nestedList) {\n        \n    }\n\n    @Override\n    public Integer next() {\n        \n    }\n\n    @Override\n    public boolean hasNext() {\n        \n    }\n}\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * NestedIterator i = new NestedIterator(nestedList);\n * while (i.hasNext()) v[f()] = i.next();\n */"},{"value":"python","text":"Python","defaultCode":"# \"\"\"\n# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n#class NestedInteger(object):\n#    def isInteger(self):\n#        \"\"\"\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\n#        :rtype bool\n#        \"\"\"\n#\n#    def getInteger(self):\n#        \"\"\"\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\n#        Return None if this NestedInteger holds a nested list\n#        :rtype int\n#        \"\"\"\n#\n#    def getList(self):\n#        \"\"\"\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\n#        Return None if this NestedInteger holds a single integer\n#        :rtype List[NestedInteger]\n#        \"\"\"\n\nclass NestedIterator(object):\n\n    def __init__(self, nestedList):\n        \"\"\"\n        Initialize your data structure here.\n        :type nestedList: List[NestedInteger]\n        \"\"\"\n        \n\n    def next(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def hasNext(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n# Your NestedIterator object will be instantiated and called as such:\n# i, v = NestedIterator(nestedList), []\n# while i.hasNext(): v.append(i.next())"},{"value":"python3","text":"Python3","defaultCode":"# \"\"\"\n# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n#class NestedInteger:\n#    def isInteger(self) -> bool:\n#        \"\"\"\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\n#        \"\"\"\n#\n#    def getInteger(self) -> int:\n#        \"\"\"\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\n#        Return None if this NestedInteger holds a nested list\n#        \"\"\"\n#\n#    def getList(self) -> [NestedInteger]:\n#        \"\"\"\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\n#        Return None if this NestedInteger holds a single integer\n#        \"\"\"\n\nclass NestedIterator:\n    def __init__(self, nestedList: [NestedInteger]):\n        \n    \n    def next(self) -> int:\n        \n    \n    def hasNext(self) -> bool:\n         \n\n# Your NestedIterator object will be instantiated and called as such:\n# i, v = NestedIterator(nestedList), []\n# while i.hasNext(): v.append(i.next())"},{"value":"c","text":"C","defaultCode":"/**\n * *********************************************************************\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * *********************************************************************\n *\n * // Return true if this NestedInteger holds a single integer, rather than a nested list.\n * bool NestedIntegerIsInteger(struct NestedInteger *);\n *\n * // Return the single integer that this NestedInteger holds, if it holds a single integer\n * // The result is undefined if this NestedInteger holds a nested list\n * int NestedIntegerGetInteger(struct NestedInteger *);\n *\n * // Return the nested list that this NestedInteger holds, if it holds a nested list\n * // The result is undefined if this NestedInteger holds a single integer\n * struct NestedInteger **NestedIntegerGetList(struct NestedInteger *);\n *\n * // Return the nested list's size that this NestedInteger holds, if it holds a nested list\n * // The result is undefined if this NestedInteger holds a single integer\n * int NestedIntegerGetListSize(struct NestedInteger *);\n * };\n */\nstruct NestedIterator {\n    \n};\n\nstruct NestedIterator *nestedIterCreate(struct NestedInteger** nestedList, int nestedListSize) {\n    \n}\n\nbool nestedIterHasNext(struct NestedIterator *iter) {\n    \n}\n\nint nestedIterNext(struct NestedIterator *iter) {\n    \n}\n\n/** Deallocates memory previously allocated for the iterator */\nvoid nestedIterFree(struct NestedIterator *iter) {\n    \n}\n\n/**\n * Your NestedIterator will be called like this:\n * struct NestedIterator *i = nestedIterCreate(nestedList, nestedListSize);\n * while (nestedIterHasNext(i)) printf(\"%d\\n\", nestedIterNext(i));\n * nestedIterFree(i);\n */"},{"value":"csharp","text":"C#","defaultCode":"/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * interface NestedInteger {\n *\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\n *     bool IsInteger();\n *\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\n *     // Return null if this NestedInteger holds a nested list\n *     int GetInteger();\n *\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\n *     // Return null if this NestedInteger holds a single integer\n *     IList<NestedInteger> GetList();\n * }\n */\npublic class NestedIterator {\n\n    public NestedIterator(IList<NestedInteger> nestedList) {\n        \n    }\n\n    public bool HasNext() {\n        \n    }\n\n    public int Next() {\n        \n    }\n}\n\n/**\n * Your NestedIterator will be called like this:\n * NestedIterator i = new NestedIterator(nestedList);\n * while (i.HasNext()) v[f()] = i.Next();\n */"},{"value":"javascript","text":"JavaScript","defaultCode":"/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * function NestedInteger() {\n *\n *     Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     @return {boolean}\n *     this.isInteger = function() {\n *         ...\n *     };\n *\n *     Return the single integer that this NestedInteger holds, if it holds a single integer\n *     Return null if this NestedInteger holds a nested list\n *     @return {integer}\n *     this.getInteger = function() {\n *         ...\n *     };\n *\n *     Return the nested list that this NestedInteger holds, if it holds a nested list\n *     Return null if this NestedInteger holds a single integer\n *     @return {NestedInteger[]}\n *     this.getList = function() {\n *         ...\n *     };\n * };\n */\n/**\n * @constructor\n * @param {NestedInteger[]} nestedList\n */\nvar NestedIterator = function(nestedList) {\n    \n};\n\n\n/**\n * @this NestedIterator\n * @returns {boolean}\n */\nNestedIterator.prototype.hasNext = function() {\n    \n};\n\n/**\n * @this NestedIterator\n * @returns {integer}\n */\nNestedIterator.prototype.next = function() {\n    \n};\n\n/**\n * Your NestedIterator will be called like this:\n * var i = new NestedIterator(nestedList), a = [];\n * while (i.hasNext()) a.push(i.next());\n*/"},{"value":"typescript","text":"TypeScript","defaultCode":"/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *     If value is provided, then it holds a single integer\n *     Otherwise it holds an empty nested list\n *     constructor(value?: number) {\n *         ...\n *     };\n *\n *     Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     isInteger(): boolean {\n *         ...\n *     };\n *\n *     Return the single integer that this NestedInteger holds, if it holds a single integer\n *     Return null if this NestedInteger holds a nested list\n *     getInteger(): number | null {\n *         ...\n *     };\n *\n *     Set this NestedInteger to hold a single integer equal to value.\n *     setInteger(value: number) {\n *         ...\n *     };\n *\n *     Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\n *     add(elem: NestedInteger) {\n *         ...\n *     };\n *\n *     Return the nested list that this NestedInteger holds,\n *     or an empty list if this NestedInteger holds a single integer\n *     getList(): NestedInteger[] {\n *         ...\n *     };\n * };\n */\n\nclass NestedIterator {\n    constructor(nestedList: NestedInteger[]) {\n\t\t\n    }\n\n    hasNext(): boolean {\n\t\t\n    }\n\n\tnext(): number {\n\t\t\n    }\n}\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * var obj = new NestedIterator(nestedList)\n * var a: number[] = []\n * while (obj.hasNext()) a.push(obj.next());\n */"},{"value":"php","text":"PHP","defaultCode":"/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *\n *     // if value is not specified, initializes an empty list.\n *     // Otherwise initializes a single integer equal to value.\n *     function __construct($value = null)\n *\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     function isInteger() : bool\n *\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\n *     // The result is undefined if this NestedInteger holds a nested list\n *     function getInteger()\n *\n *     // Set this NestedInteger to hold a single integer.\n *     function setInteger($i) : void\n *\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\n *     function add($ni) : void\n *\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\n *     // The result is undefined if this NestedInteger holds a single integer\n *     function getList() : array\n * }\n */\n\nclass NestedIterator {\n    /**\n     * @param NestedInteger[] $nestedList\n     */\n    function __construct($nestedList) {\n        \n    }\n    \n    /**\n     * @return Integer\n     */\n    function next() {\n        \n    }\n    \n    /**\n     * @return Boolean\n     */\n    function hasNext() {\n        \n    }\n}\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * $obj = NestedIterator($nestedList);\n * $ret_1 = $obj->next();\n * $ret_2 = $obj->hasNext();\n */"},{"value":"swift","text":"Swift","defaultCode":"/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     public func isInteger() -> Bool\n *\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\n *     // The result is undefined if this NestedInteger holds a nested list\n *     public func getInteger() -> Int\n *\n *     // Set this NestedInteger to hold a single integer.\n *     public func setInteger(value: Int)\n *\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\n *     public func add(elem: NestedInteger)\n *\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\n *     // The result is undefined if this NestedInteger holds a single integer\n *     public func getList() -> [NestedInteger]\n * }\n */\n\nclass NestedIterator {\n\n    init(_ nestedList: [NestedInteger]) {\n        \n    }\n    \n    func next() -> Int {\n        \n    }\n    \n    func hasNext() -> Bool {\n        \n    }\n}\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * let obj = NestedIterator(nestedList)\n * let ret_1: Int = obj.next()\n * let ret_2: Bool = obj.hasNext()\n */"},{"value":"kotlin","text":"Kotlin","defaultCode":"/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *     // Constructor initializes an empty nested list.\n *     constructor()\n *\n *     // Constructor initializes a single integer.\n *     constructor(value: Int)\n *\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\n *     fun isInteger(): Boolean\n *\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\n *     // Return null if this NestedInteger holds a nested list\n *     fun getInteger(): Int?\n *\n *     // Set this NestedInteger to hold a single integer.\n *     fun setInteger(value: Int): Unit\n *\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\n *     fun add(ni: NestedInteger): Unit\n *\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\n *     // Return null if this NestedInteger holds a single integer\n *     fun getList(): List<NestedInteger>?\n * }\n */\n\nclass NestedIterator(nestedList: List<NestedInteger>) {\n    fun next(): Int {\n        \n    }\n    \n    fun hasNext(): Boolean {\n        \n    }\n}\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * var obj = NestedIterator(nestedList)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */"},{"value":"golang","text":"Go","defaultCode":"/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * type NestedInteger struct {\n * }\n *\n * // Return true if this NestedInteger holds a single integer, rather than a nested list.\n * func (this NestedInteger) IsInteger() bool {}\n *\n * // Return the single integer that this NestedInteger holds, if it holds a single integer\n * // The result is undefined if this NestedInteger holds a nested list\n * // So before calling this method, you should have a check\n * func (this NestedInteger) GetInteger() int {}\n *\n * // Set this NestedInteger to hold a single integer.\n * func (n *NestedInteger) SetInteger(value int) {}\n *\n * // Set this NestedInteger to hold a nested list and adds a nested integer to it.\n * func (this *NestedInteger) Add(elem NestedInteger) {}\n *\n * // Return the nested list that this NestedInteger holds, if it holds a nested list\n * // The list length is zero if this NestedInteger holds a single integer\n * // You can access NestedInteger's List element directly if you want to modify it\n * func (this NestedInteger) GetList() []*NestedInteger {}\n */\n\ntype NestedIterator struct {\n    \n}\n\nfunc Constructor(nestedList []*NestedInteger) *NestedIterator {\n    \n}\n\nfunc (this *NestedIterator) Next() int {\n    \n}\n\nfunc (this *NestedIterator) HasNext() bool {\n    \n}"},{"value":"ruby","text":"Ruby","defaultCode":"# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\n#\n#class NestedInteger\n#    def is_integer()\n#        \"\"\"\n#        Return true if this NestedInteger holds a single integer, rather than a nested list.\n#        @return {Boolean}\n#        \"\"\"\n#\n#    def get_integer()\n#        \"\"\"\n#        Return the single integer that this NestedInteger holds, if it holds a single integer\n#        Return nil if this NestedInteger holds a nested list\n#        @return {Integer}\n#        \"\"\"\n#\n#    def get_list()\n#        \"\"\"\n#        Return the nested list that this NestedInteger holds, if it holds a nested list\n#        Return nil if this NestedInteger holds a single integer\n#        @return {NestedInteger[]}\n#        \"\"\"\n\nclass NestedIterator\n    # @param {NestedInteger[]} nested_list\n    def initialize(nested_list)\n        \n    end\n\n    # @return {Boolean}\n    def has_next\n        \n    end\n\n    # @return {Integer}\n    def next\n        \n    end\nend\n\n# Your NestedIterator will be called like this:\n# i, v = NestedIterator.new(nested_list), []\n# while i.has_next()\n#    v << i.next\n# end"},{"value":"scala","text":"Scala","defaultCode":"/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * trait NestedInteger {\n *\n *   // Return true if this NestedInteger holds a single integer, rather than a nested list.\n *   def isInteger: Boolean\n *\n *   // Return the single integer that this NestedInteger holds, if it holds a single integer.\n *   def getInteger: Int\n *\n *   // Set this NestedInteger to hold a single integer.\n *   def setInteger(i: Int): Unit\n *\n *   // Return the nested list that this NestedInteger holds, if it holds a nested list.\n *   def getList: Array[NestedInteger]\n *\n *   // Set this NestedInteger to hold a nested list and adds a nested integer to it.\n *   def add(ni: NestedInteger): Unit\n * }\n */\n\nclass NestedIterator(_nestedList: List[NestedInteger]) {\n    def next(): Int = {\n        \n    }\n    \n    def hasNext(): Boolean = {\n        \n    }\n}\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * var obj = new NestedIterator(nestedList)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */"},{"value":"rust","text":"Rust","defaultCode":"// #[derive(Debug, PartialEq, Eq)]\n// pub enum NestedInteger {\n//   Int(i32),\n//   List(Vec<NestedInteger>)\n// }\nstruct NestedIterator {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl NestedIterator {\n\n    fn new(nestedList: Vec<NestedInteger>) -> Self {\n        \n    }\n    \n    fn next(&self) -> i32 {\n        \n    }\n    \n    fn has_next(&self) -> bool {\n        \n    }\n}\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * let obj = NestedIterator::new(nestedList);\n * let ret_1: i32 = obj.next();\n * let ret_2: bool = obj.has_next();\n */"}],"testcase":"[[1,1],2,[1,1]]","testable":true,"templateMeta":{"name":"","params":[{"name":"nestedList","type":"list<NestedInteger>"}],"return":{"type":"integer"},"manual":true}}