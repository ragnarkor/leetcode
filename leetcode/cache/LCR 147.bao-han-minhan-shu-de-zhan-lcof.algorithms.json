{"id":100302,"fid":"LCR 147","name":"最小栈","slug":"bao-han-minhan-shu-de-zhan-lcof","link":"https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/description/","percent":55.279709487867514,"level":"Easy","category":"algorithms","en_name":"最小栈","cn_name":"最小栈","totalAC":"376.5K","totalSubmit":"680.7K","likes":540,"dislikes":0,"desc":"<p>请你设计一个 <strong>最小栈</strong> 。它提供 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>\n\n<p>&nbsp;</p>\n\n<p>实现 <code>MinStack</code> 类:</p>\n\n<ul>\n\t<li><code>MinStack()</code> 初始化堆栈对象。</li>\n\t<li><code>void push(int val)</code> 将元素val推入堆栈。</li>\n\t<li><code>void pop()</code> 删除堆栈顶部的元素。</li>\n\t<li><code>int top()</code> 获取堆栈顶部的元素。</li>\n\t<li><code>int getMin()</code> 获取堆栈中的最小元素。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[2],[-3],[],[],[],[]]\n\n<strong>输出：</strong>\n[null,null,null,null,-3,null,2,-2]\n\n<strong>解释：</strong>\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(2);\nminStack.push(-3);\nminStack.getMin(); &nbsp; --&gt; 返回 -3.\nminStack.pop();\nminStack.top(); &nbsp; &nbsp; &nbsp;--&gt; 返回 2.\nminStack.getMin(); &nbsp; --&gt; 返回 -2.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>&nbsp;<br />\n提示：</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= val &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用</li>\n\t<li><code>push</code>、<code>pop</code>、<code>top</code> 和 <code>getMin</code> 最多被调用 <code>3 * 10<sup>4</sup></code> 次</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 155 题相同：<a href=\"https://leetcode-cn.com/problems/min-stack/\">https://leetcode-cn.com/problems/min-stack/</a></p>\n\n<p>&nbsp;</p>\n","templates":[{"value":"cpp","text":"C++","defaultCode":"class MinStack {\npublic:\n    /** initialize your data structure here. */\n    MinStack() {\n\n    }\n    \n    void push(int x) {\n\n    }\n    \n    void pop() {\n\n    }\n    \n    int top() {\n\n    }\n    \n    int getMin() {\n\n    }\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj->push(x);\n * obj->pop();\n * int param_3 = obj->top();\n * int param_4 = obj->getMin();\n */"},{"value":"java","text":"Java","defaultCode":"class MinStack {\n\n    /** initialize your data structure here. */\n    public MinStack() {\n\n    }\n    \n    public void push(int x) {\n\n    }\n    \n    public void pop() {\n\n    }\n    \n    public int top() {\n\n    }\n    \n    public int getMin() {\n\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(x);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */"},{"value":"python","text":"Python","defaultCode":"class MinStack(object):\n\n    def __init__(self):\n        \"\"\"\n        initialize your data structure here.\n        \"\"\"\n\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n\n\n    def pop(self):\n        \"\"\"\n        :rtype: None\n        \"\"\"\n\n\n    def top(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n\n\n    def getMin(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n\n\n\n# Your MinStack object will be instantiated and called as such:\n# obj = MinStack()\n# obj.push(x)\n# obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.getMin()"},{"value":"python3","text":"Python3","defaultCode":"class MinStack:\n\n    def __init__(self):\n        \"\"\"\n        initialize your data structure here.\n        \"\"\"\n\n\n    def push(self, x: int) -> None:\n\n\n    def pop(self) -> None:\n\n\n    def top(self) -> int:\n\n\n    def getMin(self) -> int:\n\n\n\n# Your MinStack object will be instantiated and called as such:\n# obj = MinStack()\n# obj.push(x)\n# obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.getMin()"},{"value":"c","text":"C","defaultCode":"\n\n\ntypedef struct {\n    \n} MinStack;\n\n/** initialize your data structure here. */\n\nMinStack* minStackCreate() {\n    \n}\n\nvoid minStackPush(MinStack* obj, int x) {\n    \n}\n\nvoid minStackPop(MinStack* obj) {\n    \n}\n\nint minStackTop(MinStack* obj) {\n    \n}\n\nint minStackGetMin(MinStack* obj) {\n    \n}\n\nvoid minStackFree(MinStack* obj) {\n    \n}\n\n/**\n * Your MinStack struct will be instantiated and called as such:\n * MinStack* obj = minStackCreate();\n * minStackPush(obj, x);\n \n * minStackPop(obj);\n \n * int param_3 = minStackTop(obj);\n \n * int param_4 = minStackGetMin(obj);\n \n * minStackFree(obj);\n*/"},{"value":"csharp","text":"C#","defaultCode":"public class MinStack {\n\n    /** initialize your data structure here. */\n    public MinStack() {\n\n    }\n    \n    public void Push(int x) {\n\n    }\n    \n    public void Pop() {\n\n    }\n    \n    public int Top() {\n\n    }\n    \n    public int GetMin() {\n\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.Push(x);\n * obj.Pop();\n * int param_3 = obj.Top();\n * int param_4 = obj.GetMin();\n */"},{"value":"javascript","text":"JavaScript","defaultCode":"/**\n * initialize your data structure here.\n */\nvar MinStack = function() {\n\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMinStack.prototype.push = function(x) {\n\n};\n\n/**\n * @return {void}\n */\nMinStack.prototype.pop = function() {\n\n};\n\n/**\n * @return {number}\n */\nMinStack.prototype.top = function() {\n\n};\n\n/**\n * @return {number}\n */\nMinStack.prototype.getMin = function() {\n\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * var obj = new MinStack()\n * obj.push(x)\n * obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.getMin()\n */"},{"value":"typescript","text":"TypeScript","defaultCode":"class MinStack {\n    constructor() {\n        \n    }\n\n    push(x: number): void {\n        \n    }\n\n    pop(): void {\n        \n    }\n\n    top(): number {\n        \n    }\n\n    getMin(): number {\n        \n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * var obj = new MinStack()\n * obj.push(x)\n * obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.getMin()\n */"},{"value":"php","text":"PHP","defaultCode":"class MinStack {\n    /**\n     * initialize your data structure here.\n     */\n    function __construct() {\n\n    }\n\n    /**\n     * @param Integer $x\n     * @return NULL\n     */\n    function push($x) {\n\n    }\n\n    /**\n     * @return NULL\n     */\n    function pop() {\n\n    }\n\n    /**\n     * @return Integer\n     */\n    function top() {\n\n    }\n\n    /**\n     * @return Integer\n     */\n    function getMin() {\n\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * $obj = MinStack();\n * $obj->push($x);\n * $obj->pop();\n * $ret_3 = $obj->top();\n * $ret_4 = $obj->getMin();\n */"},{"value":"swift","text":"Swift","defaultCode":"\nclass MinStack {\n\n    /** initialize your data structure here. */\n    init() {\n\n    }\n    \n    func push(_ x: Int) {\n\n    }\n    \n    func pop() {\n\n    }\n    \n    func top() -> Int {\n\n    }\n    \n    func getMin() -> Int {\n\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * let obj = MinStack()\n * obj.push(x)\n * obj.pop()\n * let ret_3: Int = obj.top()\n * let ret_4: Int = obj.getMin()\n */"},{"value":"kotlin","text":"Kotlin","defaultCode":"class MinStack() {\n\n    /** initialize your data structure here. */\n\n\n    fun push(x: Int) {\n\n    }\n\n    fun pop() {\n\n    }\n\n    fun top(): Int {\n\n    }\n\n    fun getMin(): Int {\n\n    }\n\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * var obj = MinStack()\n * obj.push(x)\n * obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.getMin()\n */"},{"value":"dart","text":"Dart","defaultCode":"class MinStack {\n\n  /** initialize your data structure here. */\n  MinStack() {\n    \n  }\n  \n  void push(int x) {\n    \n  }\n  \n  void pop() {\n    \n  }\n  \n  int top() {\n    \n  }\n  \n  int getMin() {\n    \n  }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = MinStack();\n * obj.push(x);\n * obj.pop();\n * int param3 = obj.top();\n * int param4 = obj.getMin();\n */"},{"value":"golang","text":"Go","defaultCode":"type MinStack struct {\n\n}\n\n\n/** initialize your data structure here. */\nfunc Constructor() MinStack {\n\n}\n\n\nfunc (this *MinStack) Push(x int)  {\n\n}\n\n\nfunc (this *MinStack) Pop()  {\n\n}\n\n\nfunc (this *MinStack) Top() int {\n\n}\n\n\nfunc (this *MinStack) GetMin() int {\n\n}\n\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(x);\n * obj.Pop();\n * param_3 := obj.Top();\n * param_4 := obj.GetMin();\n */"},{"value":"ruby","text":"Ruby","defaultCode":"class MinStack\n\n=begin\n    initialize your data structure here.\n=end\n    def initialize()\n\n    end\n\n\n=begin\n    :type x: Integer\n    :rtype: Void\n=end\n    def push(x)\n\n    end\n\n\n=begin\n    :rtype: Void\n=end\n    def pop()\n\n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def top()\n\n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def get_min()\n\n    end\n\n\nend\n\n# Your MinStack object will be instantiated and called as such:\n# obj = MinStack.new()\n# obj.push(x)\n# obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.get_min()"},{"value":"scala","text":"Scala","defaultCode":"class MinStack() {\n\n    /** initialize your data structure here. */\n\n\n    def push(x: Int) {\n\n    }\n\n    def pop() {\n\n    }\n\n    def top(): Int = {\n\n    }\n\n    def getMin(): Int = {\n\n    }\n\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * var obj = new MinStack()\n * obj.push(x)\n * obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.getMin()\n */"},{"value":"rust","text":"Rust","defaultCode":"struct MinStack {\n\n}\n\n\n/**\n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl MinStack {\n\n    /** initialize your data structure here. */\n    fn new() -> Self {\n\n    }\n    \n    fn push(&self, x: i32) {\n\n    }\n    \n    fn pop(&self) {\n\n    }\n    \n    fn top(&self) -> i32 {\n\n    }\n    \n    fn get_min(&self) -> i32 {\n\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * let obj = MinStack::new();\n * obj.push(x);\n * obj.pop();\n * let ret_3: i32 = obj.top();\n * let ret_4: i32 = obj.get_min();\n */"},{"value":"racket","text":"Racket","defaultCode":"(define min-stack%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; push : exact-integer? -> void?\n    (define/public (push x)\n      )\n    ; pop : -> void?\n    (define/public (pop)\n      )\n    ; top : -> exact-integer?\n    (define/public (top)\n      )\n    ; get-min : -> exact-integer?\n    (define/public (get-min)\n      )))\n\n;; Your min-stack% object will be instantiated and called as such:\n;; (define obj (new min-stack%))\n;; (send obj push x)\n;; (send obj pop)\n;; (define param_3 (send obj top))\n;; (define param_4 (send obj get-min))"},{"value":"erlang","text":"Erlang","defaultCode":"-spec min_stack_init_() -> any().\nmin_stack_init_() ->\n  .\n\n-spec min_stack_push(X :: integer()) -> any().\nmin_stack_push(X) ->\n  .\n\n-spec min_stack_pop() -> any().\nmin_stack_pop() ->\n  .\n\n-spec min_stack_top() -> integer().\nmin_stack_top() ->\n  .\n\n-spec min_stack_get_min() -> integer().\nmin_stack_get_min() ->\n  .\n\n\n%% Your functions will be called as such:\n%% min_stack_init_(),\n%% min_stack_push(X),\n%% min_stack_pop(),\n%% Param_3 = min_stack_top(),\n%% Param_4 = min_stack_get_min(),\n\n%% min_stack_init_ will be called before every test case, in which you can do some necessary initializations."},{"value":"elixir","text":"Elixir","defaultCode":"defmodule MinStack do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec push(x :: integer) :: any\n  def push(x) do\n    \n  end\n\n  @spec pop() :: any\n  def pop() do\n    \n  end\n\n  @spec top() :: integer\n  def top() do\n    \n  end\n\n  @spec get_min() :: integer\n  def get_min() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# MinStack.init_()\n# MinStack.push(x)\n# MinStack.pop()\n# param_3 = MinStack.top()\n# param_4 = MinStack.get_min()\n\n# MinStack.init_ will be called before every test case, in which you can do some necessary initializations."}],"testcase":"[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[2],[-3],[],[],[],[]]","testable":true,"templateMeta":{"classname":"MinStack","maxbytesperline":130000,"constructor":{"params":[{"type":"integer","name":"maxSize","lang":"c","value":"64000"}],"comment":"initialize your data structure here."},"methods":[{"name":"push","params":[{"type":"integer","name":"x"}],"return":{"type":"void"}},{"name":"pop","params":[],"return":{"type":"void"}},{"name":"top","params":[],"return":{"type":"integer"}},{"name":"getMin","params":[],"return":{"type":"integer"}}],"systemdesign":true,"params":[{"name":"inputs","type":"integer[]"},{"name":"inputs","type":"integer[]"}],"return":{"type":"list<String>","dealloc":true}}}